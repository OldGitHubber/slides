const express = require('express')
const app = express()
const multer = require('multer') // This is used for multipart post i.e. from a form. Can send files
const upload = multer()

app.use(express.urlencoded({ extended: false })) // This is for put, post using url encoded so with multer covers both
app.use(express.json()) // In case the data is in json format

//*** Add swagger doc generation code
// swagger-jsdoc reads annotated source code and creates an openAPI spec. Can use for functions too
const swaggerJsDoc = require('swagger-jsdoc') // Details at npmjs.com/package/swagger-jsdoc

// swagger-ui-express serves up the auto generated documentation as an API. Use for API routes
const swaggerUI = require('swagger-ui-express')

let peopleList = {
    academics: ['Tony Nicol', 'Nicky Danino'],
    students: ['Jim Smith', 'Jane Doe', 'Billy Wibble'],
    support: ['Joe Soap', ' Sue Smith']
  }

// Now setup the options as described in the npm docs: https://swagger.io/specification/#infoObject
const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Simple Node Server',
      version: '1.0.0',
      description: `Demonstrates some http methods and associated paths and 
      how to create documentation to the openAPI standard using a code first approach`,
    },
  },
  apis: ['app.js'], // If you have other files, you can use a wild card e.g. ./public/js/*.js or list them
}

const swaggerDocs = swaggerJsDoc(options) // Create the document object. Pass in options obj
//console.log(swaggerDocs); // Use this to check all is working then take it out

// Now add app.use. This will create an API path to our documentation generated by swagger-jsdoc. 
// The functions passed in are available to all routes. swaggerUI.serve will serve up the html documntation
app.use('/docs', swaggerUI.serve, swaggerUI.setup(swaggerDocs))
// Now add the route documentation. You can use @swagger or @openapi. This is in YAML format
// ***


/**
 * @swagger
 * /:
 *   get:
 *     description: Empty path. Just returns a message.
 *     responses:
 *       200:
 *         description: Success 
 */
app.get('/', (req, res) => {
  console.log(`${req.socket.remoteAddress}`)
  res.send(`App is alive. Called from ${req.socket.remoteAddress}`)
})

/**
 * @swagger
 * /error:
 *   get:
 *     description: Just returns an error to show how it's done.
 *     responses:
 *       404:
 *         description: Not Found 
 */
app.get('/error', (req, res) => {
  res.sendStatus(404)
})

// Params sent as a query string in get
/**
 * @swagger
 * /book:
 *   get:
 *     description: |
 *       Simulates returning a book based on author and title. 
 *       Illustrates how to document a query parameter.
 *     parameters:
 *       - in: query
 *         name: author
 *         schema:
 *           type: string
 *         required: true
 *         description: Name of the author of the book you want
 *         example: Alistair MacLean
 *       - in: query
 *         name: title
 *         schema:
 *           type: string
 *         required: true
 *         description: Title of the book you want
 *         example: Where Eagles Dare
 *     responses:
 *       200:
 *         description: A message string containing the title and author
 *       404:
 *         description: Not found 
 */
app.get('/book', (req, res) => {
  let author = req.query.author
  let title = req.query.title;
  res.send(`Here is ${title} by ${author}. Enjoy.`)
})

// GET is nice and easy. POST as a bit more to it: 
// express.json to recognise and decode json
// express.urlencoded to recognise and decode url encoded data of type x-www-form-urlencoded
// multer will recognise and decode multipart form data of type form-data
// upload.none() is needed if using multer to say don't upload a file
// If you want to upload a file(s), then use const upload = multer({ dest: 'uploads/' })
// at the top of the file rather than just upload=multer()
// Details at https://www.npmjs.com/package/multer
// In OpenAPI 3.0, form data is modelled using a type:object schema where 
// the object properties represent the form fields
//
// Swagger example illustrates using &ref to reuse text and illustrates how to test for 
// different request types from multipart form, url encode form and json
/**
 * @swagger
 * /person:
 *   post:
 *     summary: Determine if a person is young or old based on the
 *     tags:
 *       - people
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/person'
 *         multipart/form-data:
 *           schema:
 *             $ref: '#/components/schemas/person'
 *         application/x-www-form-urlencoded:
 *           schema:
 *             $ref: '#/components/schemas/person'
 *     responses:
 *       200:
 *         description: |
 *           A message string describing a person who is
 *           65 years or older or a description of a person
 *           younger than 65.     
 
 *components:
 *  schemas:
 *    person:
 *      type: object
 *      properties:
 *        f_name:
 *          type: string
 *          description: Person's first name
 *          example: John
 * 
 *        l_name:
 *          type: string
 *          description: Person's last name
 *          example: Doe
 * 
 *        age:
 *          type: integer
 *          description: Person's age
 *          example: 25
 * 
 *      required:
 *        - f_name
 *        - l_name
 *        - age
 *    
*/
app.post('/person', upload.none(), (req, res) => {

  let firstName = req.body.f_name
  let lastName = req.body.l_name
  let age = req.body.age
  let ageStr = ''

  if (age >= 65) ageStr = 'ancient!'
  else
    ageStr = 'up and coming'
  res.setHeader('Content-Type', 'text/html')
  res.send(`${firstName} ${lastName} is ${ageStr}`)
})

app.delete('/person', (req, res) => {
  res.send(`User ${req.body.userId}, Tony Nicol has been permanently deleted`)
})

// Apply same logic as post
app.put('/person', upload.none(), (req, res) => {
  let oldName = req.body.curName
  let newName = req.body.newName
  let userId = req.body.userId
  res.send(`User ${userId}, ${oldName} has been updated to ${newName} and all other record attributes deleted`)
})

// Apply same logic as post
app.patch('/person', upload.none(), (req, res) => {
  let oldName = req.body.curName
  let newName = req.body.newName
  let userId = req.body.userId
  res.send(`User ${req.body.userId}, ${oldName} has been updated to ${newName} and all other record attributes unchanged`)
})

// We can also use path parameters. Say we wanted to differentiate between staff or others
// This route is not shown on the diagram
/**
 * @swagger
 * /people/{role}:
 *   get:
 *     summary: Get all people with the specified role
 *     tags:
 *       - people
 *     description: |
 *       Simulates getting names based on their role.
 *       It also illustrates how to document a path parameter.
 *     parameters:
 *       - in: path
 *         name: role
 *         schema:
 *           type: string
 *         required: true
 *         description: |
 *           Specify: academics, students or support.
 *           Returns names of people in the specified role. 
 *         example: students
 *     responses:
 *       200:
 *         description: |
 *           An array of strings containing the names of people in the requested role.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               example: ['Jim Smith', 'Jane Doe', 'Billy Wibble']
 *               
 *       404:
 *         description: Not found. 
 *         content:
 *           text/html:
 *             schema:
 *               type: string
 *               example: Role "maintenance" does not exist. 
 */
app.get('/people/:role', (req, res) => {
  let param = req.params.role
  
  switch (param) {
    case 'academics': res.send(peopleList.academics); break
    case 'students': res.send(peopleList.students); break
    case 'support': res.send(peopleList.support); break
    default: res.status(404).send(`Role "${param}" does not exist.`)
  }
})

// An example returning an object
app.get('/people', (req, res) => {
    res.send(peopleList)
})

// Start the server
app.listen(3000, () => console.log(`Listening on port 3000`))


# We need at least rabbitmq running in a container even if testing in vscode
services:
  rabbitmq:
    image: rabbitmq:3-management
    hostname: rabbitmq
    container_name: rabbitmq
    restart: unless-stopped
    
    environment:
     - RABBITMQ_DEFAULT_USER=admin # Default user name
     - RABBITMQ_DEFAULT_PASS=admin # default user password
  
    healthcheck:
      # Any of the following work
      #test: ["CMD-SHELL", "rabbitmq-diagnostics -q ping"] 
      #test: ["CMD-SHELL", "rabbitmqctl status || exit 1"]
      #test: ["CMD-SHELL", "rabbitmqctl status > /dev/null 2>&1 || exit 1"]
      test: ["CMD-SHELL", "rabbitmq-diagnostics check_running > /dev/null 2>&1 || exit 1"]
      interval: 5s
      timeout: 5s
      retries: 10
      start_period: 30s # We know it will take at least this long so test after this

    ports:
      - 5672:5672   # Message broker. Make ports same as we won't be accessing from internet
      - 15672:15672 # Management interface. Make ports same as it's meant to be accessed via the internet
    networks:
    -  net
      
    volumes:
      - rabbit-vol:/var/lib/rabbitmq  # Where to store the queued data


  producer:
    image: oldgitdocker/producer
    pull_policy: always # Attempt to always pull latest image. Lazy if not using versioning. And slow as up will always pull
    build:
      context: .   # Dockerfile in current dir
    container_name: producer
    restart: unless-stopped  # If it stops and I didn't stop it then have another go
    environment:
    - RMQ_HOST=rabbitmq
    depends_on: 
      rabbitmq:
        condition: service_healthy
    
    ports:
    - "4000:3000"
    networks:
    - net

volumes:
  rabbit-vol:
    driver: local

# # Could use default but make it more readable. Projname_net
# # But projname_default is no big deal - just showing here how net can be created
networks:
  net:
    driver: bridge